
	Include	[Sam]Start

	InclVer	SAM,Sinistar.equ
	InclVer	RICH,Speak		* Speak macro

	PushOrg	RomSav
*****
*	VERSION 17 SINISTAR - Noah's module
*
*	Changes to the last version:
*
*	Populations tuned
*
*****
	Subttl	- Pre-Noahish code
	SubTtl	- Vibration routines
****
*			PreBou - Prepares potentially vibrating object
*				 with object WS in X for a bounce
*				 passes vibration block back in U
****
	Routine	PreBou
	pshs	D		* Save them for later
	ldx	[OScan,X]	* Point to scanner WS of shaking thing
	ldu	OSChar,X	* Get characteristic descriptor
	lda	OViBas,U	* Get base address of vibration block
	leau	A,X		* Point to vibration block in scanner WS
	ldx	OSScWSA,X	* Point back to object workspace
	ldd	OLVel,X		* Get long velocity
	subd	OSLVib,U	* Subtract vibration (will be zero if still)
	std	OLVel,X		* Replace it
	ldd	OSVel,X		* Do the same for short direction
	subd	OSSVib,U
	std	OSVel,X
	puls	D,PC		* Sorry Sam and Rich
*
****
*			PosBou - Puts vibration back in object WS in X
****
	Routine	PosBou
	pshs	D,U		* Save them for later
	ldx	[OScan,X]	* Point to scanner WS of shaking thing
	ldu	OSChar,X	* Get characteristic descriptor
	lda	OViBas,U	* Get base address of vibration block
	leau	A,X		* Point to vibration block in scanner WS
	ldx	OSScWSA,X	* Point back to object workspace
	ldd	OLVel,X		* Get long velocity
	addd	OSLVib,U	* Add vibration (will be zero if still)
	std	OLVel,X		* Replace it
	ldd	OSVel,X		* Do the same for short direction
	addd	OSSVib,U
	std	OSVel,X
	puls	D,U,PC		* Sorry Sam and Rich


****
*			AddVib - Start object vibrating or add to vibration
*				 Assumes Object WS in X
****

	Routine	AddVib
	pshs	D,X,Y,U			* Save them for duration
	ldu	OChar,X			* Point to Charac. Descr. Table
	ldy	[OScan,X]		* See if this object
	cmpy	SinIndex		* Is the SiniStar
	bne	4$
*				Special Add for SiniStar
	lda	#RchMax/2		* Extra large shake (chocolate) for him
	sta	Temp
	jmp	5$

4$	ldb	OSPers,Y		* Get pseudo-mass of object
	RPT	4,lsrb			* Divide it by sixteen
	bne	6$			* If it's zero
	incb				* Make it one
6$	clra				* Compute offset into Inverse Table
	addd	#InvTbl			*
	std	Temp			* Compute inverse mass
	lda	[Temp]			*
	RPT	2,lsra			* Scale inverse mass
	sta	Temp			* Save inverse pseudo-mass in Temp
5$	lda	OViBas,U		* Give A offset of vibrate block
	ldu	[OScan,X]		* Point to scanner workspace
	leau	A,U			* Point to vibrate block in scan WS
	ldd	OSVibA,U		* Look at pointer to intelligence
	bne	1$			* If not zero, use it
	ldd	OScan,X			* Get index to scanner WS of object
	NEW_SLEEP	Task4,Vibrate,OWISLen
	std	OWSCon,X
	ldx	OIndex,X		* Get index to intelligence
	stx	OSVibA,U		* Save it as vibration intel. address
1$	lda	OSRcht,U		* Get current Richter scale
	cmpa	#RchMax			* See if it is over maximum
	bge	2$			* If so don't bother increasing

	adda	Temp			* Add degree of vibration for this mass
	sta	OSRcht,U		* And store it
2$	puls	D,X,Y,U
	rts



*
* vibrating object off screen
VIBOFF	LEAX	Y		get object workspace in X
	JSR	PreBou		kill vibration - returns vib block in U
	clrd			* Noah strikes again
	std	OSLVib,U	* zero long vibration
	std	OSSVib,U	* zero short vibration
	JMP	SCROFF

******
*		GivCrys	- Gives a crystal to a worker with scanner WS in X
******
	Routine	GivCrys
	pshs	D		* Save it from tampering
	ldd	OSScWSA,X	* Get on screen WS address
	beq	1$		* Skip this section if off screen
*
	pshs	X		* Worker on screen, save scanner WS
	ldx	OSScWSA,X	* Point to on screen address
	ldd	#DCryWor	* Get new draw routine vector
	std	OPDrwVe,X	* Update screen object data
	ldd	#CWorkCr	* New characteristic descriptor
	std	OChar,X		* Added to object WS
	puls	X		* Restore scanner WS
*
1$	ldd	#CWorkCr	* New characteristic descriptor
	std	OSChar,X	* Added to scanner WS
	ldd	SinIndex	* Get index to SiniStar
	std	OScWCR,X	* This is new caller
	lda	#OMWoCrys	* Give mission of Sinterception with crystal
	sta	OSMis,X		* To WorkerCr

*	lda	#SintrP		* Put SiniStar Intercept Priority
*			SAM - please remove the next line, uncomment
*			the previous, and change the equate of SintrP
*			to SintrP	equ	$FF
	lda	#$FF
*
	sta	OCalPri,X	* In calling priority of this worker
	puls	D
	rts

********
*		VIBRATE
*
*	Shakes things around based on their Richter scale
*
*	This routine is set up as a sleep task by GoVib routine
*	The Richter scale is a one byte value that ranges from zero
*	to RchMax (and slightly above and below, but is quickly corrected
*	to zero (vibration stops when negative, planet shatters when over
*	maximum)).
*
********

Vibrate	pshs	Y			* Save workspace for exit
	jsr	VibIni			* Load registers for vibration
	beq	5$			* If offscreen, damp vibration
4$	jsr	VibNew			* Generate and start new vibration
	puls	Y			* Restore pointer to sleep task
	Sleep	HERE			* Let it move first leg
*
	pshs	Y			* Save workspace for exit
	jsr	VibIni			* Load registers for vibration
	beq	5$			* If offscreen, damp vibration
	jsr	VibRev			* Reverse the course of vibration
	puls	Y			* Restore pointer to sleep task
	Sleep	HERE			* Let it move back to origin
*
	pshs	Y			* Save workspace for exit
	jsr	VibIni			* Load registers for vibration
	beq	5$			* If offscreen, damp vibration
	jsr	TosCrys			* Else try and toss off a crystal
*
	jsr	VibStp			* Stop current vibration
*
*			Damp Richter scale, see if we are done
*			Crystal tossing routine will go here
*
	ldd	OScan,X			* See if scanner index
	cmpd	SinIndex		* Matches the Sinistar
	beq	10$			* If so do special damping
*
	lda	OSRcht,U		* Get Richter value
	suba	#VibDamp		* Damp it down
	sta	OSRcht,U		* Replace it
	cmpa	#RchMax			* Is it above max?
	blt	2$			* if not, go on
*
	jsr	Shatter			* Else die off in spectacular manner
	clrd				* Zero out pointer
	std	OSVibA,U		* From scanner WS to vib intelligence
	clr	OSRcht,U		* And zero richter scale
	std	OSLVib,U		* And long
	std	OSSVib,U		* And short vibrations
	puls	Y			* Restore pointer to sleep task
	jmp	Die			* After it has shattered, kill vibrator
*			Exit point
*
*			Max out Richter (for sinistar only)
10$	lda	OSRcht,U		* Get Richter value
	suba	#VibDamp*2		* Damp it down
	bvc	11$			* If we underflow
	clra				* Zero it out
11$	sta	OSRcht,U		* Replace it
	cmpa	#RchMax			* Is it above max?
	blt	2$			* if not, go on
	lda	#RchMax			* Get maximum value
	sta	OSRcht,U		* into scale
*
2$	lda	OSRcht,U		* Get value again
	bpl	4$			* if still positive, do another vibe
*
1$	clr	OSRcht,U		* Else zero it out
	clrd				* Zero out pointer
	std	OSVibA,U		* From scanner WS to vib intelligence
	std	OSLVib,U		* And long
	std	OSSVib,U		* And short vibrations
	puls	Y			* Restore pointer to sleep task
	jmp	Die			* And kill process off
*			Exit point
*
*				OffScreen -  damp vibration
5$	lda	OSRcht,U
	suba	#VibDamp
	sta	OSRcht,U		* Damp vibration
	bmi	1$			* If negative, zero it all out
	puls	Y
	sleep	Vibrate			* Else wait a little longer
*			Exit point

****
*			Shatter - Die off appropriately 
****
Shatter	pshs	D,X,U			* Save them from tampering
	Tune	QBang			* Make an explosion
	ldd	#$0005			* Five points
	jsr	AddScore
	ldu	OChar,X			* Get Char. Desc.
	ldx	[OScan,X]		* Point to scanner workspace
	jsr	[OKiVec,U]		* Kill off the caller
*
2$	puls	D,X,U
	rts
*
*
*****
*			VibIni - Initialize registers for Vibrate routines
*				 On exit, zero flag set if offscreen,
*				 X = Object WS, U = Vib Block (in scan WS)
*				 Y = Characteristic descriptor
*****

VibIni	ldx	[OWSCon,Y]		* Point X to Scanner WS of Shakee
	ldy	OSChar,X		* Get characteristic descriptor
	lda	OViBas,Y		* Grab vibration base offset
	leau	A,X			* Point U to vibration block of this WS
	ldx	OSScWSA,X		* Point X to Object WS (X=0 offscreen)
	rts

*****
*			VibNew - Start a vibration from rest
*****
VibNew	ldb	OSRcht,U		* Get Richter scale value	
	clra				*
	RPT	2,aslb,rola		* Multiply by 4
	pshs	D			* Save it for later
	jsr	RndNeg			* Negate it half the time
	jsr	RndScl			* Scale it down by half half the time
	std	OSLVib,U		* This is new Long vibration rate
	addd	OLVel,X			* Add it to current object velocity
	std	OLVel,X			* And update that velocity
*
	puls	D			* Do the same for Short direction
	jsr	RndNeg			* Negate it half the time
	jsr	RndScl			* Scale it down by half half the time
	std	OSSVib,U		* This is new Short vibration rate
	addd	OSVel,X			* Add it to current object velocity
	std	OSVel,X			* And update that velocity
*
	rts

****
*			VibRev - Reverse direction of current vibration
****

VibRev	ldd	OSLVib,U		* Get current long vibration
	coma				* Negate D
	comb
	addd	#01
	std	OSLVib,U		* Save it as new vibration factor
	addd	OSLVib,U		* Double it in order to
	addd	OLVel,X			* Subtract original twice
	std	OLVel,X			* From actual velocity
*
	ldd	OSSVib,U		* Get current short vibration
	coma				* Negate D
	comb
	addd	#01
	std	OSSVib,U		* Save it as new vibration factor
	addd	OSSVib,U		* Double it in order to
	addd	OSVel,X			* Subtract original twice
	std	OSVel,X			* From actual velocity
*
	rts

****
*			VibStp - Stop current vibration
****

VibStp	ldd	OLVel,X			* Get long velocity
	subd	OSLVib,U		* Remove vibration factor
	std	OLVel,X			* Replace it
	clr	OSLVib,U		* Zero vibration factor
	clr	OSLVib+1,U
*
	ldd	OSVel,X			* Get short velocity
	subd	OSSVib,U		* Remove vibration factor
	std	OSVel,X			* Replace it
	clr	OSSVib,U		* Zero vibration factor
	clr	OSSVib+1,U
*
	rts

****
*			RndNeg - Negates D half the time
****

RndNeg	pshs	A
	RANDOM	OSEED1,BYTE
	inca				* Play with it to set flag randomly
	bmi	1$
	puls	A
	jmp	2$
1$	puls	A
	coma				* Negate D
	comb
	addd	#01
*
2$	rts
****
*			RndScl - Scales D to 1/2 value half the time
****

RndScl	pshs	A
	RANDOM	OSEED1,BYTE
	inca				* Play with it to set flag randomly
	bmi	1$
	puls	A
	jmp	2$
1$	puls	A
	asra				* Shift D right
	rorb
*
2$	rts

*****
*		Toscrys	- tosses crystals out - expects to be called from
*			  within Vibrate - X = object ws of viber, U = Vib
*			  block with L and S velocity of vibration
*****
*
	ROUTINE	TOSCRYS
	pshs	D,X,Y		* Save for exit
	ldd	#CSini		* Compare sinistar
	cmpd	OChar,X		* With this object's char desc.
	beq	1$		* If same, don't toss crystals
*
*			See if a crystal should be tossed
*
	lda	OSRcht,U	* Get vibration Richter scale
	suba	#CrProb		* Must exceed minimum vibration
	bls	1$
	pshs	A		* Save excess
	RANDOM	OSEED1,BYTE
	cmpa	S+		* Probability of tossing crystal proportional
	bhi	1$		  vibration above minimum Richter scale
*
	pshs	X		* Save object WS for now
	ldy	[OScan,X]	* Get scanner WS of vibrating rock
	lda	OSPers,Y	* Get rock's pseudo-mass
	suba	#8		* Lower it
	bcc	4$		* Never lower it past zero
	clra			* Zero is the lowest
4$	sta	OSPers,Y	* Save new pseudo-mass
	ldd	OSLPos,Y	* Get L and S position
	addd	#0101		* Offset into center of rock
	ldy	#CCrystal	* Point to crystal's CD
	jsr	[OInVec,Y]	* Initialize crystal
*			X now has Scanner WS of crystal
	puls	Y		* Put object WS of rock into Y
	ldx	OSScWSA,X	* Get object WS of crystal
	beq	3$		* If that is offscreen, skip the rest
*				  hence offscreen crystals are motionless
*
	ldd	OLVel,Y		* Then get long velocity
	subd	OSLVib,U	* Remove vibration effect
	std	OLVel,X		* Save it
	RANDOM	OSEED1,BYTE	* Generate a random number
	tfr	A,B		* Put it in low order position
	sex			* Didja hear about the assembler - it had a
*				  premature ORG-ASM
	addd	OLVel,X		* Add this random factor to velocity
	std	OLVel,X		* Replace it
*
	ldd	OSVel,Y		* Do the same for short velocity
	subd	OSSVib,U	* Remove vibration effect
	std	OSVel,X		* Save it
	RANDOM	OSEED2,BYTE	* Generate a random number
	tfr	A,B		* Put it in low order position
	sex			* Not bad, only microseconds later
	addd	OSVel,X		* Add this random factor to velocity
	std	OSVel,X		* Replace it
*
3$	lda	OSRcht,U	* Get richter scale
	lsra			* Subtract crystal damping factor
	sta	OSRcht,U	* Replace it
	jmp	2$		* All done
*
1$	jsr	Null		* Jug piece tossing could go here
*	<<< Remove this if we don't use it for jug stuff eventually >>>
2$	puls	D,X,Y
	rts

	SubTtl	- Killing subroutines
*
*			KiSubs - Killing subroutines for scanner objects
*				 expects scanner WS in X
*
*			To use for any type of object, load
*			its scanner WS into X, and its charac. desc. into
*			another index register - R in this example, then
*			jsr [OKiVec,R]		If you know what type of
*			object it is, such as Worker, you can jump directly
*			avoiding loading the C.D. as in
*			jsr KRWork		X still must have scanner WS
*
*		KRWork - Workers
*
	Routine	KRWork
	jsr	KilWor
	rts
*
*		KRWarr - Warriors
*
KRWarr	jsr	KilWar
	rts
*
*		KRWoCr - Workers with Crystals
*
KRWoCr	pshs	D,U
	ldd	OIndex,X		* Get index to scanner WS of WorkCr
	std	OScWCR,X		* Make it its own caller
	ldu	OSScWSA,X		* Point to on-screen WS
	beq	1$			* If not on screen, don't give velocity
*
	ldd	OLVel,U			* Get long screen velocity
	std	Temp			* Save it for later
	ldd	OSVel,U			* Do same for short velocity
	std	Temp+2
1$	ldu	OSLPos,X		* Get its position
	jsr	KilWor			* Kill it
	tfr	U,D			* Put position in for crystal init
	addd	#0101			* Offset it into center
	ldu	#CCrystal		* Get crystal C.D.
	jsr	[OInVec,U]		* Initialize a crystal where worker was
*				X now has scanner WS of crystal
	ldu	OSScWSA,X		* Get on-screen WS
	beq	2$			* If none, no velocity needed
*
	ldd	Temp			* Get long velocity of dead worker
	std	OLVel,U			* Give it to crystal
	ldd	Temp+2			* Do same for short velocity
	std	OSVel,U
2$	puls	D,U
	rts
*
*		KRPl1 - Planet type 1
*
KRPl1	jsr	KilVib			* Kill off vibration if present
	jsr	KilNorm			* Kill off the rock
	rts
*
*		KRPl2 - Planet type 2
*
KRPl2	jsr	KilVib			* Kill off vibration if present
	jsr	KilNorm			* Kill off the rock
	rts
*
*		KRPl3 - Planet type 3
*
KRPl3	jsr	KilVib			* Kill off vibration if present
	jsr	KilNorm			* Kill off the rock
	rts
*
*		KRPl4 - Planet type 4
*
KRPl4	jsr	KilVib			* Kill off vibration if present
	jsr	KilNorm			* Kill off the rock
	rts
*
*
*
*		KRPl5 - Planet type 5
*
KRPl5	pshs	D,U
	ldu	[OIWScIn,X]		* Get secondary intelligence WS
	ldd	#Die
	std	OExec,U			* Kill it
	jsr	KilVib			* Zero vibration
	jsr	KilCal			* Kill it off as caller
	puls	D,U
	rts
*
*		KRCrys - Crystal
*
	Routine	KRCrys
	pshs	D,U
	ldu	[OIWScIn,X]		* Get secondary intelligence WS
	ldd	#Die
	std	OExec,U			* Kill it
	jsr	KilCal			* Kill it off as caller
	puls	D,U
	rts
*
*		KRSBomb - Sinibomb
*
KRSBomb	pshs	D,U
	ldu	[OIWScIn,X]		* Get secondary intelligence WS
	ldd	#Die
	std	OExec,U			* Kill it
	jsr	KilCal			* Kill it off as caller
	dec	InBombs
	puls	D,U
	rts
*
*		KRSini - Sinistar
*
*			In Rich's stuff
*
*		KRPlay - Player
*
KRPlay	jsr	KilCal			* This may not work right.....
*					  It will try to kill screen image
	rts
*
*		KRPiec - Sinitstar Piece
*
KRPiec	jsr	KilNorm			* Kill off the piece
	rts

*
*
*			KilVib - Stops vibration (if any) with scan WS in X
*
KilVib	pshs	D,X,Y			* They all may get used...
	ldy	OSChar,X		* Get characteristics descriptor
	lda	OViBas,Y		* Get base offset of vibration block
	ldy	[A,X]			* Load Y with sleep task WS of vib task
	beq	1$			* If grounded, just return
	ldd	#Die			* Else make it die when it wakes up
	std	OExec,Y
1$	puls	D,X,Y,PC		* Done
	LOCAL

********************
*
*		Killer routines - lobotomizes objects, then forces them
*				  to commit suicide
*
*		These routines expect scanner WS address in X on entry
********************

KilWor
	pshs	D,Y,U			* Kill Worker entry point
	lda	#OWorker		* Get offset for worker
	jmp	ComSta			* Go to common starting point
*
KilWar
	pshs	D,Y,U			* Kill Warrior entry point
	lda	#OWarrior		* Warrior offset
*
ComSta	pshs	A			* Save callee offset
	ldd	OSScWsA,X		* Look at on-screen WS address
	beq	2$			* Skip next section if not on screen
*
*			Kill off On-Screen Object
*
	pshs	X			* Save scanner workspace we are killing
	tfr	D,X			* Load in on-screen WS address
	jsr	ExpObj			* Explode it	
	ldd	#NoPost			* Make sure it doesn't
	std	OPDrwVec,X		* Leave a crystal behind
	puls	X			* And restore the scanner WS pointer
*
2$	ldy	[OScnIn,X]		* Get controlling intelligence task
	ldd	#Die			* Kill it off
	std	OExec,Y			* When it wakes up
	ldy	OIndex,X		* Get index to scanner WS
	cmpy	OScWCr,X		* Is this callee called by itself?
	beq	3$			* If so, don't bother to notify caller
*
*			Send condolences to the caller of this craft
*
	ldu	[OScWCr,X]		* Point to caller's scanner WS
	lda	,S			* Get callee type
	leay	OQuota,U		* Point to quota bytes
	dec	A,Y			* Remove this craft from quota
	lsla				* Double callee ofset for 2 byte use
	adda	#OCleLs			* Point to callee list
	ldy	OIndex,X		* Get index of craft we are killing
	cmpy	A,U			* Is it the same as the first entry?
	beq	4$			* If so, we don't have to look for him
	ldu	[A,U]			* Point to first workspace
	lda	#OScSqI			* And pass the offset of squadron list
	jsr	Look4Y			* Then search until we find ID in Y
*
4$	ldy	OScSqI,X		* Get squadron pointer of goner
	sty	A,U			* Save it in next squadron member
*
*			Now De-link our callee from type list
*
3$	lda	,S			* Get the good old offset
	lsla				* Double it for 2 byte operation
	ldu	#KeyClee		* Point to keystone of callees
	ldy	OIndex,X		* Get our callee's index
	cmpy	A,U			* Is ours first in line?
	beq	5$			* If so we're all set
*
	ldu	[A,U]			* Point to first workspace in list
	lda	#OScTyp			* Set up correct offset
	jsr	Look4Y			* Look for a match with Y
*
5$	ldy	OScTyp,X		* Get the next link from the goner
	sty	A,U			* Give it to his predecessor
	tfr	X,Y			* Load in goner's scanner WS
	jsr	BumOut			* Depress him to death
	leas	1,S			* Remove callee offset from stack
	puls	D,Y,U			* And we're all done
	rts
	local

***
*			KilCall - Kills off caller intelligent object
***

KilCall	pshs	D,Y,U

	ldu	OSChar,X	* Look at characteristics descriptor
	lda	OViBas,U	* Vibration base offset
	beq	2$		* If it can't vibrate skip next section

*			Stop Vibration task if present

	pshs	X		* Save scanner WS
	ldy	[A,X]		* Get WS of vibrating sleep task
	ldd	#Die		* And if it dies when it does wake
	std	OExec,Y		* I pray EXEC its soul to take
	puls	X		* Restore scanner workspace

*			Kill Onscreen object

2$	ldd	OSScWSA,X
	beq	1$		* If not on screen, skip this section
	pshs	X		* Save scanner WS
	ldx	OSScWSA,X	* Get screen object WS
	ldd	OChar,X		* Check to see
	cmpd	#CCrystal	* If it is a crystal
	beq	8$		* If so, kill it
	jsr	ExpObj		* Else explode it	
	jmp	9$
8$	jsr	KillObj
9$	puls	X		* Restore scanner workspace

*			Tell the slaves their master is dead

1$	lda	#OMWoEvade	* This is new mission
	ldu	[OCleLs,X]	* Get scanner WS of first worker
	jsr	Lincoln		* Free the slaves
	lda	#OMWaDrift	* This is new mission
	ldu	[OCleLs+2,X]	* Get scanner WS of first warrior
	jsr	Lincoln		* Do it again
	ldy	[OSCOCAI,X]	* Get WS of controlling caller intelligence
	ldd	#Die		* Make it die when it wakes
	std	OExec,Y
	tfr	X,Y		* Set up for killing scanner workspace
	jsr	Bumout		* Cause scanner process to die on wakeup
	puls	D,Y,U		* Restore stuff
	rts


****
*			Lincoln - go down squadron list freeing callees
*				  Alters D,Y,U
****
Lincoln	pshs	A
2$	beq	1$		* If workspace is grounded, return
	lda	,S		* Get mission
	sta	OSMis,U		* Give it new mission
	ldd	#$FFFF		* With faked maximum distance
	std	OScLDC,U	* To that caller
	lda	#1
	sta	OSSqSiz,U	* And a squadron size of 1
	lda	#WrstPri	* Get worst possible priority
	sta	OCalPri,U	* New calling priority
	ldd	OIndex,U	* Get index to this callee
	std	OScWCr,U	* It is its own caller
	ldy	OScSqI,U	* Get index to next member of squadron
	ldd	#Ground		* Ground out
	std	OScSqI,U	* That pointer
	ldu	,Y		* Point to workspace of next guy
	jmp	2$		* Keep going
*
1$	puls	A
	rts

*****
*			KilNorm - Kills off scanner WS in X and screen object
*****

	local
KilNorm	pshs	D,X
	ldd	#ScanDie		* Put scanner killer
	std	OExec,X			* Into execution vector
	ldx	OSScWSA,X		* Get screen workspace
	beq	1$			* If zeroed, no screen object
	jsr	ExpObj			* Explode it if there
1$	puls	D,X,PC
	local


************
*		SUBROUTINES
************

*			Look4Y - searches through links in workspaces for index
*				 value in Y.  U is first WS, A is offset of
*				 link.  On exit U is WS with link = Y
Look4Y
	cmpy	A,U			* Is this link the right one?
	beq	1$
	ldu	[A,U]			* Point to next
	jmp	Look4Y
1$	rts

*
*			BumOut - Cause WS in Y to commit suicide on wakeup
*
Bumout
	pshs	D
	ldd	#ScanDie		* Get address of death code
	std	OExec,Y			* New execution (how appropriate)
	puls	D,PC

	SubTtl	- Explosion routines

	Local
*****
*		EXPOBJ - Explodes object - gets object WS in X
*****

	Routine	SExpObj
	pshs	D,X,Y,U
	ldy	#$FFFF		* Set flag for time delay explosion
	jmp	ExEntr		* Go to explosion entry point

	Routine	ExpObj
	pshs	D,X,Y,U
	ldy	#0		* Set flag for immediate explosion

	Routine	ExEntr
	jsr	FragExp		* Toss off fragments if needed
*
*			Call up Bob's special explosion routines if needed
*
	CMPX	#WPLAYER
	BNE	22$
	JSR	PLXQUE			* START UP PLAYER EXPLOSION
	BRA	23$
22$	LDD	OCHAR,X
	CMPD	#CWARRI
	BNE	23$
	JSR	WRXQUE			* START UP WARRIOR EXPLOSION

23$	ldd	#CExplo		* Give this object WS explosion charac. desc.
	std	OChar,X
	leau	,X		* Transfer X over to U
	cmpy	#0		* See if we need a time delay
	beq	2$		* If not, go do immediate explosion
*
*				Delayed explosion
*
	New_Sleep	Task8,PrePlo,OExpLen	* Spawn controlling task
	jmp	3$
*						
*				Immediate explosion
*
2$	New_Sleep	Task1,PrePlo,OExpLen	* Spawn controlling task

	ldd	#INull		* Immediate explosion, nullify image right away
	std	ONiDesc,U	* Null new image descriptor
	ldd	#ChgObj		* Make sure it changes to null object
	std	ODrwVec,U	* Next time it wakes


3$	stu	OSWSA,X		* Save object ws address for sleep task
	clr	OImNo,X		* So tell sleep task we are on image number 0
	dec	OImNo,X		* Then bring it to -1 so we START with image 0
	ldx	OIndex,X	* Get index to this sleep task
	stx	OScan,U		* Not really a scanner WS, but will do for now
	puls	D,X,Y,U
	rts
*
*			PrePlo	- Precedes Plode routine, changes sleep times
*
PrePlo	Sleep	1$		* Go back to sleep for another cycle
1$	Change_Sleep	Task4,Plode	* Tell it to wake at Plode

	local
*			Plode	- Sleep task to control explosion
*
	Routine	Plode
	pshs	D,X,Y
	ldx	OSWSA,Y		* Get on-screen WS of our explosion
	lda	OImNo,Y		* Find out what image number we are on
	inca			* Go to next
	cmpa	#4		* See if we are done
	bge	1$		* Go die if so
	sta	OImNo,Y		* Else save it for next time
	ldb	#OILen		* Multiply image descr. length
	mul			* By number of image in A
	addd	#IExplo		* Add this offset to first image
	std	ONIDesc,X	* Update screen image
	ldd	#ChgObj
	std	ODrwVec,X	* And tell it to change object
	puls	D,X,Y
	sleep	LOOP		* Sleep till next update
*
1$	cmpx	#WPlayer
	bne	5$
	ldd	#INull
	std	ONiDesc,X
	ldd	#ChgObj
	std	ODrwVec,X
	jmp	6$

5$	jsr	KillObj		* Kill image off first
6$	puls	D,X,Y
	jmp	Die		* Then die too
	local

	SubTtl	- Initialization

*
*		Player Initialization
*
	Vector	PlaVec

	clr	SiniKills	* I clear it so initial rstpop is correct
	jsr	RstPop		* Reset population and difficulty tables

	rts
*
*				Turn Initialization
*

	Vector	IniVec

*			Entry Point for Turn initialization
	ldu	#Pop
1$	clr	,U		* Zero out current number of things in sector
	leau	3,U		* Point to next thing
	cmpu	#Pop+21		* See if we are at end of list
	blt	1$		* If not keep going
*
	local
	ldx	#Ground
	stx	KeyClee
	stx	KeyClee+2	* Start out the type lists empty

	ldy	#8080		* Load code for random positioning
	clra
	sta	Edge		* And set flag so they are not created on edge
	jsr	PopFil		* And fill the sector to match desired pop.
* Initialize Player
	ldu	#CPlayer
	jsr	[OInvec,U]
* Create Sinistar
	lda	#$FF
	sta	Edge		* On edge
	ldd	#$8080		* random position
	ldu	#CSini		* Point to Char. Descr.
	jsr	[OInVec,U]	* Jump to initialization subroutine

	New_Sleep	Task256,DTimer

	New_Sleep	Task0,AdjPop	* Start population adjuster going

	New_Sleep	Task64,SinCon	* Start Sinistar Hector build and taunt

*
*		If in Void zone (sinikill mod 4 = 0) do not have swarms
*
	local
	lda	SiniKill
	beq	1$		* do it on first time
	anda	#$03		* Mod 4
	beq	2$
*				Start swarms

1$	New_Sleep	Task256,HanSolo

2$	nop			* Probably unnecessary
*
	local
	IFN	Version-Final
	Local			* Patch for Rich to add workCR at init
RicPat	lda	#0
	ldu	#CWorkCr
	sta	Temp
1$	dec	Temp
	bmi	2$
	jsr	[OInvec,U]	* Make a WorkCr
	jmp	1$
	ENDIF

2$	rts



	SubTtl	- Initialization Subroutines

*			InSubs - Initialization subroutines
*				 Expect position in D, return index to
*				 Scanner WS in X
*
*			To call these routines, either load characteristic
*			descriptor of object to initialize into a register -
*			R in this example - load scanner position into D, and
*			jsr	[OInVec,R]
*			Or if you need only a specific characteristic object
*			such as workers, you can skip loading a register and
*			jsr	IRWork		with position in D
*
*		IRWork - Workers
*
IRWork	New_Scan	CWorker		* Get scanner WS
	jsr	InWorker		* Give it Worker primary intelligence
	rts
*
*		IRWarr - Warriors
*
IRWarr	New_Scan	CWarrior	* Get scanner WS
	jsr	InWarrior		* Give it Warrior primary intelligence
	rts
*
*		IRWoCr - Workers with Crystals
*
IRWoCr	New_Scan	CWorkCr		* Get scanner WS
	jsr	InWorker		* Give it Worker primary intelligence
	jsr	GivCrys			* Give it a crystal
	rts
*
*		IRPl1 - Planet type 1
*
IRPl1	New_Scan	CPlan1		* Get scanner WS
	jsr	Vibzer			* Zero out vibration block
	rts
*
*		IRPl2 - Planet type 2
*
IRPl2	New_Scan	CPlan2		* Get scanner WS
	jsr	Vibzer			* Zero out vibration block
	rts
*
*		IRPl3 - Planet type 3
*
IRPl3	New_Scan	CPlan3		* Get scanner WS
	jsr	Vibzer			* Zero out vibration block
	rts
*
*		IRPl4 - Planet type 4
*
IRPl4	New_Scan	CPlan4		* Get scanner WS
	jsr	Vibzer			* Zero out vibration block
	rts
*
*		IRPl5 - Planet type 5
*
IRPl5	pshs	U
	New_Scan	CPlan5		* Get scanner WS
	pshs	X			* Save scanner WS
	jsr	VibZer			* Zero out vibration block
	jsr	InCaller		* Give it Caller primary intelligence
	New_Sleep	Task64,PlSecIn,OWISLen	* Start secondary intelligence
	ldu	,S			* Get planet scanner WS
	ldd	OIndex,U		* Get index to scanner WS
	std	OWSCon,X		* This is controlled WS of sec. intel.
	ldd	OIndex,X		* Then save index of secondary intel.
	std	OIWScIn,U		* In appropriate place in scanner WS
	puls	X,U			* Restore old values - scan WS in X
	rts
*
*
*		IRCrys - Crystal
*
	Routine	IRCrys
	pshs	U
	New_Scan	CCrystal	* Get scanner WS
	pshs	X			* Save scanner WS
	jsr	InCaller		* Give it Caller primary intelligence
	New_Sleep	Task64,CrSecIn,OCrSILn	* Start secondary intelligence
	ldu	,S			* Get crystal scanner WS
	ldd	OIndex,U		* Get index to scanner WS
	std	OWSCon,X		* This is controlled WS of sec. intel.
	ldd	OIndex,X		* Then save index of secondary intel.
	std	OIWScIn,U		* In appropriate place in scanner WS
	clr	OCrAge,X		* Zero out age of crystal
	puls	X,U			* Restore old values - scan WS in X
	rts
*
*		IRSBomb - Sinibomb
*
IRSBomb	pshs	U
	New_Scan	CSbomb		* Get scanner WS
	pshs	X			* Save scanner WS

1$	RANDOM	OSEED1,BYTE	* Give the Sinibomb a (pseudo) random
	sta	OSPERS,X	*   personality so that it THINKS better.
***
*	The personality must be set so that all the Sinibombs don't "think"
*	at the same time.
***
	jsr	InCaller		* Give it Caller primary intelligence
	New_Sleep	Task8,SiniBo,OWISLen	* Start secondary intelligence
	ldu	,S			* Get sinibomb scanner WS
	ldd	OIndex,U		* Get index to scanner WS
	std	OWSCon,X		* This is controlled WS of sec. intel.
	ldd	OIndex,X		* Then save index of secondary intel.
	std	OIWScIn,U		*   in appropriate place in scanner WS
	puls	X,U			* Restore old values - scan WS in X
	rts
*
*		IRSini - Sinistar
*
IRSini	New_Scan	CSini		* Get scanner WS
*
*				This section from RICH
	RANDOM	OSEED1,BYTE
	anda	#!N(PSiniInhibit)
	ora	#MaxSinOrbit
	sta	OSPERS,X
*
*
	jsr	Vibzer			* Zero out its vibration block
	jsr	InCaller		* Give it Caller primary intelligence
	ldd	OIndex,X		* Get index to Sinistar
	std	SinIndex		* Save it for others to use
	New_Sleep	Task256,SiniPa	* Pre-sinistar intelligence
	rts
*
*		SiniPause - Pauses for two seconds before starting to move
*
SiniPa	Change_Sleep	Task8,Sini	* Make it wake on faster list
*
*		IRPlay - Player
*
	Routine	IRPlay
	pshs	A,B,X,Y,U	* Save work registers
	ldx	[PlaIndex]	* X -> Player's scanner workspace.
	tst	AMDemo		* If in attract mode demo
	bne	1$		*   then create a special player.
	jsr	InCaller	* Give the player calling intelligence.
	bra	99$		* Exit
***
*	Start the auto pilot.
***
1$	jsr	InWarrior	* <<< Temporary, as a warrior >>>
99$	puls	A,B,X,Y,U	* Restore work registers
	rts


* InWorker - gives intelligence to worker - WS in X on entry
InWorker
	pshs	D		* Save D from subsequent tampering
	ldd	KeyClee		* Get the pointer to the first worker
	std	OScTyPt,X	* Save it in our 'same type' pointer
	clra			* Zero out
	sta	OCalPri,X	* Calling priority
	sta	OSSqSiz,X	* And squadron size
	ldd	#$FFFF		* Save maximum possible distance
	std	OSCLDC,X	* In the distance to caller (special init)
	ldd	#Ground		* Then ground out
	std	OScSqI,X	* Pointer to index of next squadron member
	lda	#OMWoDrift	* Put a drift mission
	sta	OSMis,X		* In the mission slot
	RANDOM	OSEED1,BYTE	* Create a random personality
	sta	OSPERS,X	*   for each of the workers.
	ldd	OIndex,X	* Get the index to this worker
	std	OScWCr,X	* It is calling itself now
	std	KeyClee		* It is also new first worker on type list
	New_Sleep	Task8,Worker,OWISLen	* Start intelligence sleep task
* X now has WS of intelligence sleep task, not Scanner task
	std	OWsCon,X	* Put controlled scanner ws index in sleep task
	ldd	OIndex,X	* Then get this index to return the favor
	ldx	[OWSCon,X]	* Point X back at scanner WS
	std	OScnIn,X	* Save it as pointer to intelligence task
	puls	D,PC		* And we are done

* InWarrior - gives intelligence to Warrior - WS in X on entry

	Routine	InWarrior
	pshs	D		* Save D from subsequent tampering
	ldd	KeyClee+2	* Get the pointer to the first Warrior
	std	OScTyPt,X	* Save it in our 'same type' pointer
	clra			* Zero out
	sta	OCalPri,X	* Calling priority
	sta	OSSqSiz,X	* And squadron size
	ldd	#$FFFF		* Save maximum possible distance
	std	OSCLDC,X	* In the distance to caller (special init)
	ldd	#Ground		* Then ground out
	std	OScSqI,X	* Pointer to index of next squadron member
	lda	#OMWaDrift	* Put a drift mission
	sta	OSMis,X		* In the mission slot
	RANDOM	OSEED1,BYTE	* Create a random personality
	pshs	Y		* Save Y for later
	leay	,X		* Get warrior scanner WS into Y
	jsr	Inhibit		* Initialize warrior inhibitions.
	puls	Y		* restore value
	sta	OSPERS,X	*   for each of the warriors.
	ldd	OIndex,X	* Get the index to this Warrior
	std	OScWCr,X	* It is calling itself now
	std	KeyClee+2	* It is also new first Warrior on type list
	New_Sleep	Task8,Warrior,OWISLen	* Start intelligence sleep task
* X now has WS of intelligence sleep task, not Scanner task
	std	OWsCon,X	* Put controlled scanner ws index in sleep task
	ldd	OIndex,X	* Then get this index to return the favor
	ldx	[OWSCon,X]	* Point X back at scanner WS
	std	OScnIn,X	* Save it as pointer to intelligence task
	puls	D
	rts			* And we are done

* InCaller - give intelligence to Caller - Scan WS in X on entry, IQ WS on exit
	Routine	InCaller
	pshs	D,U		* Save D from subsequent tampering
	ldd	#Ground		* First ground out
	std	OCleLs,X	* Pointer to list of workers
	std	OCleLs+2,X	* Pointer to list of warriors
	clrd
	ldu	OSChar,X	*
	cmpu	#CCrystal	*
	bne	1$		*
	tst	AMDemo		* Ask Sam about this.
	bne	1$		*
	incb			* Fake out the quota as filled.
1$	std	OQuota,X	* Then zero quotas - none filled so far
	ldd	OIndex,X	* Get the index to this Caller
	New_Sleep	Task1,PreCal,OWISLen	* Start intelligence sleep task
* X now has WS of intelligence sleep task, not Scanner task
	std	OWsCon,X	* Put controlled scanner ws index in sleep task
	ldd	OIndex,X	* Then get this index to return the favor
	ldx	[OWSCon,X]	* Point X back at scanner WS
	std	OSCoCaI,X	* Save pointer to Controlling Caller Intel.
	puls	D,U		* And we are done
	rts
*
*
*			VibZer - Zeros out vibration block of Scan WS in X
*				 and initializes pseudo-mass
*
	ROUTINE	VibZer
	pshs	D,X,U		* Save them for later
	ldu	OSChar,X	* Point to characteristic descriptor
	lda	OMass,U		* Get the object mass
	sta	OSPers,X	* Copy it into the personality byte
	lda	OViBas,U	* Get the offset of base of vibration block
	leau	A,X		* Point U to block in scanner WS
	clrd			* Put zeros into
	std	,U++		* Vibration task address
	std	,U++		* Long vibration added
	std	,U++		* Short vibration added
	sta	,U		* Richter scale value
	puls	D,X,U
	rts

* intelligence routines
	SubTtl	- Calling Intelligence

*		PRECAL - precedes first call, sets CalOne flag
*
PreCal	clr	CalOne
	dec	CalOne		* Set it to FF without using registers
	jmp	Caller		* Go do the first call
*
*
*		POSCAL - after first calling, resets calling to slow list
*
PosCal	clr	CalOne		* Now we are no longer on first call
	ldd	#SPlayer
	cmpd	OWSCon,Y	* See if it is the player being called
	bne	1$
	Change_Sleep	Task64,Caller	* Player calls twice as often as others
*
1$	Change_Sleep	Task256,Caller	* Make them wake at caller routine
	Local

* Enter from sleep - Y points to Sleep Task of Caller

Caller	pshs	Y			* Save pointer for sleep at exit
	ldy	[OWsCon,Y]		* Reposition Y to Controlling Intel. WS
	ldx	OSChar,Y		* Point X to characteristic descriptor
	lda	OInType,X		* Grab the intelligence type for TLU
	sta	Temp+OCler		* Save it as "Caller" type
	lda	#OWorker		* Start out by calling Workers
	sta	Temp+OClee		* To keep track of Callee type
* See if we have our quota of callees yet
1$	adda	Temp+OCler		* Add Caller to Callee now in A
	sta	Temp+OCombo		* This is our combined calling code
	ldx	#Quota			* Quota table `Eventually in RAM`
	ldb	A,X			* Load correct quota for this Combo
	lda	Temp+OClee		* Get Callee offset again
	leax	OQuota,Y		* Point to Quota slots for caller
	cmpb	A,X			* See if number of callees equals quota
	bhi	4$			* If quota greater, quota is unfilled
* A pass is completed, see if another is to be done
2$	lda	Temp+OClee		* See who our callee is
	beq	3$			* if still worker, keep on going
	jmp	17$			* If not zero (worker) is warrior, done
* First pass - workers - done, now check for warriors
3$	lda	#OWarrior		* Get offset for Warriors
	sta	Temp+OClee		* They are callee type now
	jmp	1$			* Go back to quota checking loop
* Quota unfilled, calculate our modified priority
4$	ldb	A,X			* Number of Callees of type on call
	lda	#QuoMod			* How importance quota is to priority
	mul				* Scale current quota filled
	stb	Temp+OQtaFct		* Save this modified quota factor
* Find our unmodified priority for this combo
	lda	Temp+OCombo		* Number unique to Caller/Callee pair
	ldx	#Prios			* Address of priority table
	ldb	A,X			* Do Table Look Up for unmodified prio
	subb	Temp+OQtaFct		* Subtract quota contribution from Prio
	stb	Temp+OPriMod		* This is our modified priority
* Set up for searching through callees
	addb	#DMoMax			* Add in the best possible distance mod
	stb	Temp+OPriMax		* For our maximum possible calling prio
	lda	#WrstPri		* Worst acceptable priority
	sta	Temp+OBstPri		* Best priority found so far
	clrd
	std	Temp+ObstClee		* Best callee found - initialized to 0
	lda	Temp+OClee		* Get current callee type offset
	asla				* Double it for 2 byte offset
	ldx	#KeyClee		* Point to keystone lookup for callees
	ldx	A,X			* Grab the appropriate Callee Keystone
	jmp	6$			* On first pass, skip type pointer load
* Top of search loop - look through callees
5$	ldx	OScTyPt,X		* get pointer to next callee of type
6$	cmpx	#Ground			* Does next callee exist?
	beq	11$			* If not, see if we found real one yet
	ldx	,X			* Point X to Scanner WS of next callee
	ldd	OScWCr,X		* See if this callee's caller
	cmpd	OIndex,Y		* Is the caller now trying to call it
	beq	5$			* If so, go on to next callee
	lda	Temp+OPriMax		* Check our best possible priority
	cmpa	OCalPri,X		* Against callee's mission priority
	bls	5$			* If less, we can't possibly override
	lda	#$FF			* Check for 'override' value
	cmpa	OCalPri,X		* In callee priority slot
	beq	5$			* If FF, is on special call, ignore
* May be possible to call this one - check dist, make sure
	lda	OSLPos,X		* Get his long position
	cmpa	OSLPos,Y		* Compare it with our long position
	blt	7$			* If ours is higher (signed)
	suba	OSLPos,Y		* Then subtract his
	jmp	8$
7$	lda	OSLPos,Y		* Else subtract us from him
	suba	OSLPos,X
8$	ldb	OSSPos,X		* Get his short position
	cmpb	OSSPos,Y		* Compare it with our short position
	blt	9$			* If ours is higher (signed)
	subb	OSSPos,Y		* Then subtract his
	jmp	10$
9$	ldb	OSSPos,Y		* Else subtract us from him
	subb	OSSPos,X
10$	std	Temp+OHisDs		* Save his distance, he may be best
	jsr	CalDm			* Then calculate the distance modifier
	sta	Temp+OMoDst		* This is modified distance factor
	adda	Temp+OPriMod		* Add it to modified priority
	sta	Temp+OurPri		* To get our actual final priority
* Calculate callee's real priority given his distance
	ldd	OSCLDC,X		* Distance of callee from its caller
	jsr	CalDm			* Calculate its distance modifier
	adda	OCalPri,X		* Add it to its base calling priority
	sta	Temp+OHisPri
	lda	Temp+OurPri		* Get our priority
	cmpa	Temp+OHisPri		* Compare it with his current priorty
	bls	5$			* If no better, look at next callee
* Eligible Callee found, see if it is the best so far
	cmpa	Temp+OBstPri		* Compare this prio with best so far
	bls	5$			* If no better, keep going
	sta	Temp+OBstPri		* Else this is now the best priority
	ldd	OIndex,X		* Get index to the callee
	std	Temp+OBstClee		* Save it as index to best callee
	ldd	Temp+OHisDs		* Get his distance to us
	std	Temp+OBstDs		* Distance of best callee found
* Do Minimum Unconditional Acceptance Distance modifier check
	lda	Temp+OMoDst		* Get the distance mod to this callee
	cmpa	#MUAD			* This should be RAM location `
	bls	5$			* if not over MUAD, keep looking
* Got one - or checked all without finding one within MUAD
11$	lda	Temp+OBstPri		* Look at the best priority we found
	cmpa	#WrstPri		* Is it better than worst acceptable?
	lbls	2$			* If not, see if we need another pass
* Valid Callee found - update him, his caller, this caller
	ldx	[Temp+OBstClee]		* Point X to best callee's workspace
	ldu	[OScWCr,X]		* Point to former caller of callee
	cmpu	[OIndex,X]		* See if it's calling itself (uncalled)
	beq	16$			* If so, no list to delete it from
	lda	Temp+OClee		* Get offset for this callee type
	adda	#OQuota			* Point A to right callee/quota
	dec	A,U			* One less callee of that type now
	bpl	12$			* Error check - should not be needed`
	swi		*	'No Callee in list'`
* In final version, delete the bpl 12$ and swi`
12$	lda	Temp+OClee		* Get callee offset
	lsla				* Double it for two byte offset
	adda	#OCleLs			* Point to start of proper callee list
	ldu	A,U			* Look at first callee
	cmpu	OIndex,X		* See if he is the one we want
	bne	13$			* If not, search down list
* First callee is one we want
	ldu	[OScWCr,X]		* Point to former caller of callee
	leau	A,U			* Point to its first callee entry
	ldd	OScSqI,X		* Get next member of callee's squadron
	std	,U			* Now is new first callee of old caller
	jmp	16$			* Go attend to callee
* Not first callee - look down list til you find it
13$	ldd	OIndex,X		* This is our callee's ID
	ldu	,U			* Point U to Workspace of first callee
14$	cmpd	OScSqI,U		* Compare each callee in list to ours
	beq	15$
	ldu	[OScSqI,U]		* Point to WS of next squadron member
	IFE	VERSION-FINAL
	bra	14$
	ELSE
	cmpu	#Ground			* See if we missed it somehow
	bne	14$
	swi		*	'Callee not present on Caller list'`
	ENDIF
15$	ldd	OScSqI,X		* Get next member of callee's squadron
	std	OScSqI,U		* Now it takes place of callee
* Now update our Caller's quota and list
16$	lda	Temp+OClee
	adda	#OQuota			* Calculate proper quota byte addr.
	inc	A,Y			* Update our caller's quota total
	lda	Temp+OClee
	lsla				* Double offset for two byte lookup
	leau	OCleLs,Y		* Point to callee list origin
	leau	A,U			* Point to correct set of callees
	ldd	,U			* Get old first squadron member
	pshs	D			* Save it for below
	ldd	OIndex,X		* Get index to callee
	std	,U			* New callee becomes first squ. member
* Now tell the callee his new destination
	lda	Temp+OPriMod		* Get our priority for this call
	sta	OCalPri,X		* Save it in Callee's WS
	ldd	OIndex,Y		* Get caller's index
	std	OScWCr,X		* Save as Scanner Ws of Caller
	ldd	Temp+OBstDs		* Get his distance to us
	std	OSCLDC,X		* Save this as distance to caller
	puls	D			* Get first (most junior) old sq member
	std	OScSqI,X		* Link into new squadron list
	ldu	#MisAss			* Point to table of mission assignments
	lda	Temp+OCombo		* Get our unique combination code
	lda	A,U			* Get mission
	sta	OSMis,X			* Give it to new callee
	jmp	2$			* See if we need another pass
17$	puls	Y			* Restore index to sleep task
	lda	CalOne			* See if its the first call for caller
	beq	20$
	jmp	PosCal			* Do changesleep if so, else
20$	Sleep	LOOP			* Return to sleep


*	CALDM -	Calculate squared distance between scanner coords and modify
*		Coords in A,B, returns distance modifier in A
CalDm	coma				* Reverse the magnitude of A and B to
	comb				* gain accuracy on small distances
	pshs	B			* Use stack for temporary storage
	tfr	A,B			* Get long coord
	mul				* Square it
	lsra				* Scale it to avoid overflow
	pshs	A			* Save result
	lda	1,S			* Get short dist.
	ldb	1,S
	mul
	lsra				* Scale it to avoid overflow
	adda	,S			* Add in square of long distance
	leas	2,S			* Clear garbage from stack, result in A
	ldb	#DstMod			* Scale it by distance modifier
	mul
	rts

	SubTtl	- Secondary Intelligences - Crystals, Planets
****
*
*			CrSecIn - Crystal secondary intelligence - WS in Y
*
CrSecIn	inc	OCrAge,Y	* Age it
	bvc	1$		* No problem if no overflow
	dec	OCrAge,Y	* Else bring it back down to FF
1$	lda	OCrAge,Y	* Then grab it for later
	ldx	[OWSCon,Y]	* Get scanner WS this intelligence controls
	ldu	OSScWSA,X	* Look at its object WS
	bne	7$		* If onscreen, zero its age and return
	cmpa	#MaxCrA		* Compare this age to maximum crystal age
	blo	3$		* If this age is lower, don't kill the crystal
*
	jsr	KRCrys		* Crystal dies of old age
	jmp	2$		* Then return
*
7$	clr	OCrAge,Y	* Crystal back on screen - new lease on life
	JMP	CRONSEC
*
3$	lda	OQuota,X	* Look at quota of workers now called
	beq	2$		* If zero, forget it
	FRANDOM	OSEED1,BYTE
	cmpa	#CatPrb		* Do a random check against catching probabil.
	bhi	2$		* If higher, no one has caught this crystal
*				  else someone gets it if they're near enough
	ldu	[OCleLs,X]	* Point to WS of first worker
*
4$	lda	#CryDis		* Get minimum crystal catch distance acceptable
	cmpa	OScLDC,U	* Compare to long dist. to caller
	blo	5$		* If too far, look at next worker
	cmpa	OScSDC,U	* Else check short distance too
	blo	5$		* With same consequences
*
	ldd	OSScWSA,U	* It is close enough - see if it is on screen
	beq	6$		* If not on screen, go give it the crystal
*
5$	ldu	[OScSqI,U]	* Look at WS of next squadron member
	bne	4$		* If not at end of list, check him out
*
2$	Sleep	LOOP		* Exit point
*
6$	jsr	KRCrys		* Kill the crystal off
	tfr	U,X		* Point to worker getting crystal
	jsr	GivCrys		* Give it to him
	jmp	2$		* All done
* crystal onscreen secondary intelligence
CRONSEC	CHANGE_SLEEP TASK8,HERE	switch to faster list for flashing
	BSR	2$		still on screen?
	FRANDOM	OSEED1,BYTE	50% chance of flashing
	BMI	1$		flash this time?
	SLEEP	LOOP		no, try again next time
1$	RANDOM	OSEED1,WORD	yes, don't all flash at once
	CHANGE_SLEEP TASK1,HERE	switch to one list for effect
	BSR	2$		still on screen?, get screen WS address in U
	LDD	#ICFLASH	change crystal image to flash image
	STD	ONIDESC,U
	LDD	#CHGOBJ
	STD	ODRWVEC,U
	TUNE	QCRYFLA		play crystal flash tune
	SLEEP	HERE		wait one screen before erasing
	BSR	2$		still on screen?, get screen WS address in U
	LDD	#ICRYSTA	change crystal image back to normal image
	STD	ONIDESC,U
	LDD	#CHGOBJ
	STD	ODRWVEC,U
	BRA	CRONSEC		back to flashing list
*
2$	LDX	[OWSCON,Y]	get scanner WS this intelligence controls
	LDU	OSSCWSA,X	get at its object WS in U
	BEQ	3$		if offscreen, switch to offscreen sec intel
	RTS
*
3$	LEAS	2,S		offscreen, forget about returninig
	CHANGE_SLEEP TASK64,CRSECIN change back to offscreen intelligence
	LOCAL
*
*
*			PlSecIn - Calling Planet sec. intelligence - WS in Y
*
PlSecIn	ldx	[OWSCon,Y]	* Get scanner WS this intelligence controls
	ldu	OSScWSA,X	* Look at its object WS
	bne	2$		* If onscreen, ignore it and return
*
	lda	OQuota+OWorker,X	* Look at quota of workers now called
	beq	2$		* If zero, forget it
*
	lda	OQuota+OWarrior,X	* Look at quota of warriors now called
	beq	2$		* If zero, forget it
	RANDOM	OSEED1,BYTE
	cmpa	#MinPrb		* Do a random check against mining probabil.
	bhi	2$		* If higher, no mining this check
*				  else someone gets it if they're near enough
*
*			Check to see if the warrior is nearby
*
	ldu	[OCleLs+2,X]	* Point to WS of first warrior
*
	lda	#MinDis		* Get minimum mining distance acceptable
	cmpa	OScLDC,U	* Compare to long dist. to caller
	blo	2$		* If too far, forget it
	cmpa	OScSDC,U	* Else check short distance too
	blo	2$		* With same consequences
*
*			Warrior close, look for a worker close enough
*
	ldu	[OCleLs,X]	* Point to WS of first worker
*
4$	lda	#MinDis		* Get minimum crystal catch distance acceptable
	cmpa	OScLDC,U	* Compare to long dist. to caller
	blo	5$		* If too far, look at next worker
	cmpa	OScSDC,U	* Else check short distance too
	blo	5$		* With same consequences
*
	ldd	OSScWSA,U	* It is close enough - see if it is on screen
	beq	6$		* If not on screen, go give it the crystal
*
5$	ldu	[OScSqI,U]	* Look at WS of next squadron member
	bne	4$		* If not at end of list, check him out
*
2$	Sleep	LOOP		* Exit point
*
6$	ldd	OSLPos,U	* Get scanner position of this worker
	tfr	U,X		* Put his WS in X
	jsr	KRWork		* Kill him
	jsr	IRWoCr		* Make a worker with crystal in his place
	jmp	2$		* All done
	LOCAL

*
	SubTtl	- Misc. constant-running processes
*
*
*		ADJPOP - Adjust Population to desired levels
*			 	Wakes with sleep task in Y
*
	Local
AdjPop	pshs	Y
	ldy	#8080		* Flag to create randomly, avoiding player ship
	lda	#-1		* Edge flag
	sta	Edge		* Save it so we initialize on edge of sector
	jsr	PopFil		* Fill the sector to desired population level
	puls	Y
	SLEEP	LOOP

*
*		POPFIL - Fills out current population to desired level
*			 Expects location/random create flag in Y
*			 Expects EDGE to be non-zero to create on edge only
*			 Uses TEMP
	Local
	Routine	PopFil
	pshs	D,X,U
	LDA	EDGE		is this initialization?
	BEQ	6$
	CLRA			no, determine how far behind we are: total in A
	LDX	#POP		get start of population table in X
4$	LDB	1,X		get number needed
	SUBB	X		subtract number in existance
	BLS	5$		need more?
	PSHS	B		add to total needed
	ADDA	S+
	BCC	5$		over 255?
	IFE	VERSION-FINAL
	LDA	#-1		are you kidding?
	ELSE
	SWI
	ENDIF
5$	LEAX	3,X		next entry
	CMPX	#EPOPVL		done
	BLO	4$
	TSTA			any to populate?
	BEQ	3$
	RPT	3,LSRA		divide by 8 (create about 16 at a time max.)
	BEQ	6$		only need a few? zero flags create all
	LDX	#INVTBL		find inverse
	LDA	A,X
6$	STA	TEMP		save percentage to create (or zero for 100%)
	ldx	#ScOCDT		* X points at scanner object CD table
	ldu	#Pop		* U points at Population current/desired table
*
2$	LDA	1,U		get desired pop level for this type
	SUBA	U		subtract current level
	BLS	1$		if we are at or past desired level, do next
	LDB	TEMP		get percentage to create
	BEQ	7$		flaged as create all?
	MUL			no, compute how many to create
7$	TSTA			make any?
	BEQ	1$
	pshs	X,A		* Save pointer to SCOCDTable and number to make
8$	ldd	Free		* Check free space
	cmpd	#MinFree	* Don't create if less than a minimum
	blt	9$
	ldx	[1,S]		* Put Char. Desc. in X
	tfr	Y,D		* Put it on the edge of the screen if so told
	jsr	[OInVec,X]	* Initialize the object
	DEC	S		more to create
	BNE	8$
9$	puls	X,A		* Restore pointer
*
1$	leau	3,U		* Point at next entry
	leax	2,X		* Point to next CD
	cmpx	#RSOEnd		* At the end of the replacable scanner objects?
	bne	2$		* If not, look at next
*
3$	puls	D,X,U
	rts

	Local
*
*			HANSOLO - Famous flyer through asteroid swarms
*
HanSolo	lda	Pop+0D		* Look at number of smallest planetoids desrd.
	cmpa	20		* See if it is at swarm value
	blt	1$		* If not, we are OK
*
	lda	#2		* Otherwise put desired number of two
	sta	Pop+0D		* In smallest
	sta	Pop+0A		* And second smallest planet 'desired' count
	jmp	2$
*
1$	Random	OSeed1,BYTE
	cmpa	#SwrPrb		* See if we are within swarm probability
	bhi	2$		* if not just return
*
	lda	20		* Else put a whole mess of small planets
	sta	Pop+0D
	sta	Pop+0A		* Into the desired count
	DISPLAY	YELLOW		* Point to text window
	Phrase	YELLOW,35,Entering,Swarm
	Phrase	YELLOW,35,Of,Planetoids
	Tune	QMesg
*				Warn the player
*
2$	sleep	LOOP		* Go back to sleep while they multiply

*
*		SinCon	- SiniStar controlling process - speech and O-Sec build
*
SinCon	pshs	D
	ldd	Finish
	cmpd	#Alive
	beq	1$		* See if SiniStar is alive yet
*
*			SiniStar dormant
*
	tst	SiniSec		* not alive yet, see if in sector
	beq	4$		* if not, no action this iteration
	RANDOM	OSEED2,BYTE
	cmpa	#$40		* Some of the time build him up automatically
	nop
	nop
	nop		* room for operator adjust stuff
	bhi	4$		* Sometimes don't
*
	jsr	AddPart
	jmp	4$
*
*			SiniStar LIVES!
*
1$	RANDOM	OSEED2,BYTE
	cmpa	#$38		* Toss a random number
	bhi	4$		* sometimes don't say anything
	jsr	Taunt		* Else say something nasty
*
4$	puls	D
	SLEEP	LOOP

*
*		Taunt - speak out a random taunt
*
	Routine	Taunt
	pshs	A
	RANDOM	OSEED1,BYTE
	anda	#$7F			* Knock it down to 1-7F
	adda	RnSpch			* Add in the last random speech
	sta	RnSpch			* Update it for next time
*
	cmpa	#$28
	bhi	1$

	Speak	3
	jmp	10$
*
1$	cmpa	#$50
	bhi	2$

	Speak	4
	jmp	10$
*
2$	cmpa	#$78
	bhi	3$

	Speak	5
	jmp	10$
*
3$	cmpa	#$A0
	bhi	4$

	Speak	6
	jmp	10$
*
4$	cmpa	#$C8
	bhi	5$

	Speak	7
	jmp	10$
*
5$	Speak	8
10$	puls	A
	rts		* End of TAUNT

	Local
*
	SubTtl	- Difficulty adjustment code

	Routine	DTimer
	lda	#01
	jsr	ChgA
	fdb	.DifTmr
	Sleep	LOOP

* Temporary tables for caller intelligence
	SubTtl	- Caller Intelligence Tables
*****
*
* Unusual notes:
*
*	The attract mode demonstration was kludged to allow planets and
*	crystals to call the player.  Normally only workers and warriors
*	are called by anything.  But, to make the demo work, the player
*	is given a special warrior intelligence during attract mode.  As
*	a consequence, the quota for crystals calling warriors is 1 (one)
*	instead of 0 (zero).  Also, the mission for crystals calling warriors
*	is OMWaInt(ercept) instead of OMWaDrift and the priority is $34+1
*	instead of $00.  (The $34 is the same as the planet calling priority
*	and the +1 causes it to prefer crystal pickup to mining.)
*
*****
* Quota assignments - temporarily in ROM
Quota	fcb	3,1		* 3 workers, 1 warrior for planets
	fcb	3,9		* lots of each for the player
	fcb	0,6		* 6 warriors for the sinistar
	fcb	1,1		* 1 of each for sinibombs
	fcb	3,1		* 3 workers for crystals
*				  3 rings for the Elven kings under the sky
*				  7 for the Dwarf-lords in their halls of stone
*				  9 for the Mortal Men, doomed to die
*				  1 for the SiniStar, when its full grown

* Mission assignments - SHOULD STAY IN ROM
MisAss		fcb	OMWoTail,OMWaMine	* Planets
		fcb	OMWoTail,OMWaAttack	* Player
		fcb	OMWoDrift,OMWaTail	* Sinistar
		fcb	OMWoInt,OMWaInt		* Sinibombs
		fcb	OMWoInt,OMWaInt		* Crystals

*			Base Priorities - temporarily in ROM
Prios	fcb	$58,$58		* Temporary base priorities for planets
	fcb	$48,$5B		* Player
	fcb	$00,$54		* Sinistar
	fcb	$70,$70		* Sinibomb
	fcb	$68,$58+3	* Crystals

*
*
*			KExplo	- offscreen routine for explosion
*
KExplo	ldx	[OScan,Y]
	ldd	#Die
	std	OExec,X		* Kill off controlling task
	leax	,Y		* Point X to object WS
	jsr	KillObj		* Kill on screen object
	jmp	Exec2		* I think this is where I'm supposed to go???


* sinistar piece onto screen transition
	ROUTINE	SPIECON
	JSR	SEXPOBJ		slowly blow it up
	WAKE_AT	SCANDIE
	RTS


	PULLORG	ROMSAVE

	PushOrg	CExplo+OOffSc
	fdb	KExplo	* Offscreen routine
	PullOrg

	SubTtl	- Population tables
*
*			Characteristic Table additions
*
	Pushorg	CWorker+OCDInd
	fdb	Pop+0
	PullOrg
*
	Pushorg	CWarrior+OCDInd
	fdb	Pop+3
	PullOrg
*
	Pushorg	CWorkCr+OCDInd
	fdb	Pop+0
	PullOrg
*
	Pushorg	CPlan1+OCDInd
	fdb	Pop+6
	PullOrg
*
	Pushorg	CPlan2+OCDInd
	fdb	Pop+9
	PullOrg
*
	Pushorg	CPlan3+OCDInd
	fdb	Pop+0C
	PullOrg
*
	Pushorg	CPlan4+OCDInd
	fdb	Pop+0F
	PullOrg
*
	Pushorg	CPlan5+OCDInd
	fdb	Pop+12
	PullOrg
*
	Pushorg	CSBomb+OCDInd
	fdb	Pop+15
	PullOrg
*
	Pushorg	CCryst+OCDInd
	fdb	Pop+18
	PullOrg
*
	Pushorg	CSini+OCDInd
	fdb	Pop+1B
	PullOrg
*
	Pushorg	CPlayer+OCDInd
	fdb	Pop+1E
	PullOrg
*

	PushOrg	RomSav

ScoCdt	fdb	CWorker		* Scanner Object Charac. Descrip. Table
	fdb	CWarrior
	fdb	CPlan1
	fdb	CPlan2
	fdb	CPlan3
	fdb	CPlan4
	fdb	CPlan5
RSOEnd	equ	*		* End of replaceable scanner objects
	fdb	CSBomb
	fdb	CCryst
	fdb	CSini
	fdb	CPlayer
CdtEnd	equ	*		* End of table
*
*			Initial Population table
*
*	SAM - you can put those new tables here
*
*
*			Initial Population tables
* 	Population tables have one-byte current population, two byte
*	desired population (LSB is fractional part) for each CD in
*	Scanner Object Char. Desc. Table (see ScOCDT)
*	Sequence of waves: InPop0,2,3,4,1,2,3,4,1,2,3,4 etc.
*

*		InPop0 - Initial population for first wave only

InPop0	fcb	0,6,0		* Workers
	fcb	0,0,0		* Warriors
	fcb	0,10.,0		* Type 1 planets
	fcb	0,2,0		* Type 2 planets
	fcb	0,2,0		* Type 3 planets
	fcb	0,2,0		* Type 4 planets
	fcb	0,2,0		* Type 5 planets
*			NOTE: objects past this point are NOT initialized
*				automatically, but are included for con-
*				sistency, and to zero out the current values
	fcb	0,0,0		* SiniBombs
	fcb	0,0,0		* Crystals
	fcb	0,1,0		* SiniStar
	fcb	0,1,0		* Player

IP0End	rmb	0		* Marks end of table
*
*
*		Difficulty increase figures for this population
*
InDif0	fdb	DTime
	fcb	6
	fdb	.PWor		* Workers
	fcb	10
	fdb	.PWar		* Warriors
	fcb	-8
	fdb	.PPl1		* Plan1's
	fcb	10
	fdb	.PPl3		* Plan3's
	fcb	3
	fdb	.PPl5		* Plan5's
	fcb	$7F
	fdb	.WAgg		* Warrior aggression
	fcb	0

ID0End	rmb	0		* Marks end of diff. table

*		InPop1 - Void Zone

InPop1	fcb	6		* Workers
	fcb	8		* Warriors
	fcb	1		* Type 1 planets
	fcb	1		* Type 2 planets
	fcb	1		* Type 3 planets
	fcb	1		* Type 4 planets
	fcb	3		* Type 5 planets
*			NOTE: objects past this point are NOT initialized
*				automatically, but are included for con-
*				sistency, and to zero out the current values
	fcb	0		* SiniBombs
	fcb	0		* Crystals
	fcb	1		* SiniStar
	fcb	1		* Player
*
*
*		Difficulty increase figures for this population
*
	fdb	DTime
	fcb	6
	fdb	.PWor		* Workers
	fcb	10
	fdb	.PWar		* Warriors
	fcb	-1
	fdb	.PPl1		* Plan1's
	fcb	-1
	fdb	.PPl3		* Plan3's
	fcb	3
	fdb	.PPl5		* Plan5's
	fcb	$7F
	fdb	.WAgg		* Warrior aggression
	fcb	0

ID1End	rmb	0		* Marks end of diff. table

*		InPop2 - Worker Zone

InPop2	fcb	10		* Workers
	fcb	3		* Warriors
	fcb	10.		* Type 1 planets
	fcb	2		* Type 2 planets
	fcb	2		* Type 3 planets
	fcb	2		* Type 4 planets
	fcb	2		* Type 5 planets
*			NOTE: objects past this point are NOT initialized
*				automatically, but are included for con-
*				sistency, and to zero out the current values
	fcb	0		* SiniBombs
	fcb	0		* Crystals
	fcb	1		* SiniStar
	fcb	1		* Player
*
*
*		Difficulty increase figures for this population
*
	fdb	DTime
	fcb	10.
	fdb	.PWor		* Workers
	fcb	10
	fdb	.PWar		* Warriors
	fcb	-8
	fdb	.PPl1		* Plan1's
	fcb	10
	fdb	.PPl3		* Plan3's
	fcb	3
	fdb	.PPl5		* Plan5's
	fcb	$7F
	fdb	.WAgg		* Warrior aggression
	fcb	0

*		InPop3 - Warrior Zone

InPop3	fcb	4		* Workers
	fcb	10.		* Warriors
	fcb	10.		* Type 1 planets
	fcb	2		* Type 2 planets
	fcb	2		* Type 3 planets
	fcb	2		* Type 4 planets
	fcb	2		* Type 5 planets
*			NOTE: objects past this point are NOT initialized
*				automatically, but are included for con-
*				sistency, and to zero out the current values
	fcb	0		* SiniBombs
	fcb	0		* Crystals
	fcb	1		* SiniStar
	fcb	1		* Player
*
*
*		Difficulty increase figures for this population
*
	fdb	DTime
	fcb	4
	fdb	.PWor		* Workers
	fcb	10
	fdb	.PWar		* Warriors
	fcb	-8
	fdb	.PPl1		* Plan1's
	fcb	10
	fdb	.PPl3		* Plan3's
	fcb	3
	fdb	.PPl5		* Plan5's
	fcb	$7F
	fdb	.WAgg		* Warrior aggression
	fcb	0

*		InPop4 - Planetoid Zone

InPop4	fcb	6		* Workers
	fcb	8		* Warriors
	fcb	10		* Type 1 planets
	fcb	2		* Type 2 planets
	fcb	10		* Type 3 planets
	fcb	2		* Type 4 planets
	fcb	5		* Type 5 planets
*			NOTE: objects past this point are NOT initialized
*				automatically, but are included for con-
*				sistency, and to zero out the current values
	fcb	0		* SiniBombs
	fcb	0		* Crystals
	fcb	1		* SiniStar
	fcb	1		* Player
*
*
*		Difficulty increase figures for this population
*
	fdb	DTime
	fcb	6
	fdb	.PWor		* Workers
	fcb	10.
	fdb	.PWar		* Warriors
	fcb	10
	fdb	.PPl1		* Plan1's
	fcb	10
	fdb	.PPl3		* Plan3's
	fcb	3
	fdb	.PPl5		* Plan5's
	fcb	$7F
	fdb	.WAgg		* Warrior aggression
	fcb	0



*
*		DEMO Population figures
*

InPopD	fcb	0,2,0		* Workers
	fcb	0,0,0		* Warriors
	fcb	0,4,0		* Type 1 planets
	fcb	0,4,0		* Type 2 planets
	fcb	0,4,0		* Type 3 planets
	fcb	0,4,0		* Type 4 planets
	fcb	0,5,0		* Type 5 planets
*			NOTE: objects past this point are NOT initialized
*				automatically, but are included for con-
*				sistency, and to zero out the current values
	fcb	0,0,0		* SiniBombs
	fcb	0,0,0		* Crystals
	fcb	0,1,0		* SiniStar
	fcb	0,1,0		* Player
*
*
*		Difficulty increase figures for this population
*
	fdb	DTime
	fcb	6
	fdb	.PWor		* Workers
	fcb	1
	fdb	.PWar		* Warriors
	fcb	1
	fdb	.PPl1		* Plan1's
	fcb	1
	fdb	.PPl3		* Plan3's
	fcb	3
	fdb	.PPl5		* Plan5's
	fcb	$7F
	fdb	.WAgg		* Warrior aggression
	fcb	0
*
InOEnd	rmb	0		* End of table

.PPL1	fdb	Pop+7		* Type 1 planet difficulty table root
	fcb	0

.PPL3	fdb	Pop+0D		* Type 3 planet difficulty table root
	fcb	0


*	Following routine goes after tables so assembler does not object

****
*		RstPop	- Resets population initial values and increments
*			  To be called at PLAVEC and after each sinistar death
****

	Routine	RstPop
	pshs	D,X,Y,U
	clrd			* Zero out difficulty stuff
	std	Dtime
	std	WAgg

	tst	AmDemo		* See if we are in demo mode
	beq	5$		* Go see sinikills if not in demo mode

	ldx	#InPopD		* And load X with beginning of demo for loading
	jmp	2$		* Go load demo table in

5$	lda	SiniKills	* See how many SiniStars have been killed
	bne	1$		* Go do special init if we are not on first

	ldx	#InPop0
	jmp	2$		* Go load in Pop 0 tables

1$	anda	#$03		* Screen out lowest two bits for wave value
	ldb	#(ID1End-InPop1)
	mul			* Multiply wave (0-3) by length of table
	addd	#InPop1		* Add in beginning location
	tfr	D,X		* Put it in X for special load beginning loc

	LDU	#POP		special load: start at beginning of population
7$	LDA	X+		get population value
	CLRB			no fraction
	STD	1,U		reset population to new value
	LEAU	3,U		next extry
	CMPU	#EPOPVL		done?
	BLO	7$
	BRA	6$		now load difficulty

2$	ldu	#Pop		* Tell it to start at the beg of the population
	ldd	#EPopVl		* Tell it to stop at the end of the population
	std	EndPop
	jsr	SloLod		* Load the chosen init pop table
6$	ldu	#.DifTmr	* Tell it to start at beg of diff. table
	ldd	#EDifVl		* Tell it to stop at end of diff. table
	std	EndPop
	jsr	SloLod		* Load the diff table following the pop table

4$	cmpb	SiniKills	* in number of sinistars killed
	bhs	3$		* If so, return
	stb	Temp		* Save it for next try

	lda	#06		* Else take a number

	pshs	X
	ldx	#GA1		* Operator difficulty adjust
	jsr	RCmosB		* Read from CMOS
	puls	X

	mul			* Calculate difficulty add based on oper. diff.
	tfr	B,A		* Put result in A (will be 30. for avg. diff.)
	jsr	ChgA		* Add that difficulty
	fdb	.DifTmr		* To difficulty timing structure
	ldb	Temp		* Get counter of difficulty waves advanced
	addb	#4		* Set it ahead another set of waves
	jmp	4$		* And see if that is enough for now


3$	pshs	X
	ldx	#GA1		* Operator difficulty adjust
	jsr	RCmosA		* Read from CMOS
	puls	X


	jsr	ChgA		* bump up the difficulty a bit at the beginning
	fdb	.DifTmr		* depending on operator setting 

	LDA	SINIKIL		get number of sinistars killed
	BNE	11$
	LDA	#99		first zone use blue
	BRA	22$
11$	LDX	#ZCOLTBL	get address of zone color table
	ANDA	#3		offset into table # of sinistar kills mod 4
	LDA	A,X		get color
22$	STA	ZONECOL		save as new color
	JSR	FRAME		re-draw frame with new color
* * *
	PULS	D,X,Y,U

	rts

****
*		SloLod	- Slow data load for population stuff - source in X
*			  Dest. in U, destination end stored in ENDPOP
*			  Destoys B
****

SloLod	ldb	,X+
	stb	,U+
	cmpu	EndPop
	blo	SloLod
	rts

	PullOrg	RomSav

	PushOrg	PlaySav
.DifTmr	rmb	(ID0End-InDif0)
*				 reserve space for difficulty table
	PullOrg	PlaySav

EPopVl	equ	Pop+(IP0End-InPop0)
EDifVl	equ	.DifTmr+(ID0End-InDif0)

	PushOrg	RomSav

	VECTOR	IAMVECT

	New_Sleep	Task1,Attract,OTimer

	RTS

Attract	
	nop
	nop
	rts


WrXQue
	nop
	nop
	rts		* Warrior explosion, ROUTINE'd by Bob

PlXQue
	nop
	nop
	rts		* Player explosion, likewise

	PullOrg	RomSav
